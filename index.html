<!doctype html>
<html>
  <head>
    <title>Game Thing</title>
  </head>
  <body>
  <div id="nameGet">
   Enter your name : <input type="text" name="name" id="name">
  
   
    <button onclick="initGame()">GO</button>
  </div>
  </body>
  <script src="/socket.io/socket.io.js"></script>
  <script src="/js/hexi.js"></script>
  <script src="https://code.jquery.com/jquery-1.11.1.js"></script>
    <script>
    var socket = io();
    

  
  function mainLoop(){
  
    //ping();
  
  }

  
  //Dont need to load and files for now
  thingsToLoad = [];
  var g;
  //Syncs per sec
  SYNC_RATE = 10;
  
  var mapWidth;
  var mapHeight;
  var id;
  var name;
  var camera;
  var map;
  var towers;
  var base;
  var mapLoaded = false;
  var mapCon;
  var linesCon;
  var towersCon;
  var gridSize;
  function setup(){
  
    
    camera = g.group();
   
    socket.emit('join',name);
   
   //Lets test to see if I can
    mapCon = new PIXI.Container();
	linesCon = new PIXI.Container();
	towersCon = new PIXI.Container();
   
   
   
   loadMap();
    g.state = play;
    
  }
  
  function load(){

  
 
  }
 
  
  function play(){
      
        //This is the render Loop
        if(mapLoaded == false){
            if(map != undefined){
                reloadMap();
                mapLoaded = true;
            }
        
        }else{
        
            panMap();
        
        }
        
        if(mapCon.children.length == 0){
        
            drawMapBackGround();
        
        }
  }
  
  function initGame(){
  
	name = $('#name').val();
	
    gridSize = 40;
    
    
	$("#nameGet").remove();
    //$("#grid").remove();
    
  
	g = hexi($(window).width(),$(window).height(),setup);
	g.fps = 60;
	g.scaleToWindow();
	g.backgroundColor = 0xFFFFFF;
  
    var myitem = g.canvas;
    if (myitem.addEventListener)
    {
        // IE9, Chrome, Safari, Opera
        myitem.addEventListener("mousewheel", MouseWheelHandler, false);
        // Firefox
        myitem.addEventListener("DOMMouseScroll", MouseWheelHandler, false);
    }else{
        //Old IE Support not sure if it should relly be here
        myitem.attachEvent("onmousewheel", MouseWheelHandler);
    }

  
	g.pointer.press = function () {
		//console.log("The pointer was pressed");
		//for(var i =0;i < mapCon.children.length;i++){
    
			//if(isHitByMouse(mapCon.getChildAt(i))){
			if(g.hit(g.pointer,camera)){
        
        
				
				var data = {};
				data.id = id;
                //Division is correct for zoom
                //Sub is to corect for panning
				data.x = Math.floor(((g.pointer.x-camera.x)/camera.scaleX)/gridSize);
				data.y = Math.floor(((g.pointer.y-camera.y)/camera.scaleY)/gridSize);
				socket.emit('turret', data);
            
            //console.log("Esitmated pos : " + Math.floor(g.pointer.x/gridSize) + " " + Math.floor(g.pointer.y/gridSize));
			//break;
			}
		//}
	};

	//Add a custom `release` method
	g.pointer.release = function () {
		//console.log("The pointer was released");
		
	};

	//Add a custom `tap` method
	g.pointer.tap = function () {
    
	};
  
  
  g.start();
  
}
 
    function isHitByMouse(child){
    
        //Scaled child measurements 
        childScaledWidth = child.width * camera.scaleX;
        childScaledXPos = child.x * camera.scaleX;
        childScaledYPos = child.y * camera.scaleY;
       
        mouseX = g.pointer.x
        mouseY = g.pointer.y
            
        //Do point vs rect collision
        
        //X Bounds
        if(mouseX < childScaledXPos + childScaledWidth && mouseX > childScaledXPos){
            //Y Bounds
                if(mouseY < childScaledYPos + childScaledWidth && mouseY > childScaledYPos){
                return true;
                }
        }
    
    return false;
    }
 
    function panMap(){

        var buffer = 100;
        var triggerRange = 100;
        var panSpeed = 7
        
       
        if(camera.y < camera.height - camera.height/2){
            //Can move the camera down
            if(g.pointer.y < triggerRange){
                //Mouse is on the top side of the screen
               
                    camera.y += panSpeed 
                
            }
            
        
        }else{
            console.log("BOUND HIT at " + camera.y );
        }

        if(-1 * camera.y < camera.height - camera.height/2){
            //Can move the camera up
            if(window.innerHeight - g.pointer.y < triggerRange){
                //Mouse is on the bottom edge of the screen
               
                    camera.y -= panSpeed;
                
            }
        }
    
        if(camera.x < camera.width - camera.width/2){
            //Can move the camera down
            if(g.pointer.x < triggerRange){
                //Mouse is on the top side of the screen
               
                    camera.x += panSpeed 
                
            }
            
        
        }

        if(-1 * camera.x < camera.width - camera.width/2){
            //Can move the camera up
            if(window.innerWidth - g.pointer.x < triggerRange){
                //Mouse is on the bottom edge of the screen
               
                    camera.x -= panSpeed;
                
            }
        }
    
    
    }
 
    function MouseWheelHandler(e)
    {
    // cross-browser wheel delta
    var e = window.event || e; // old IE support
    var delta = Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail)));
    //Shamelessly stolen from stack overflow 
    
    var damper = 20;
    
    camera.scaleX = camera.scaleX + delta/damper;
    camera.scaleY = camera.scaleY + delta/damper;
    
    //Bound the zoom
    if(camera.scaleX < 0.1){
        camera.scaleX = 0.1;
        camera.scaleY = 0.1;
    }
    
    return false;
}
 
	function drawMapBackGround(){
		mapCon.removeChildren();
		for(var i = 0;i < mapWidth;i++){
		
			for(var k = 0;k < mapHeight;k++){
                //console.log("Creating child with dims : " + gridSize + " at pos " + (i*gridSize) + " , " + (k*gridSize));
 				mapCon.addChild(g.rectangle(gridSize , gridSize, "white","black",5,i*gridSize,k*gridSize));
			}
		
		}
	
	}
 
	function drawMapLines(){
	
		if(map == undefined){
		return;
		}
	
		linesCon.removeChildren();
    
		var line;

		
		
		for(var i = 0;i < map.length;i++){
			for(var k = 0;k < map[i].length;k++){
        
				if(map[i][k] == null){
					//There is nothing here, meaning the path cant reach it
					//mapCon.addChild(g.rectangle(50 , 50, "white","grey",5,i*50,k*50));
           
        
				}else{
					//Path can reach this location so draw like normal
				
					line = g.line();
					line.ax = i*gridSize + gridSize/2;
					line.ay = k*gridSize + gridSize/2;
					line.bx = map[i][k].x * gridSize + gridSize/2;
					line.by = map[i][k].y * gridSize + gridSize/2;
            
					linesCon.addChild(line);
				}
        
			}
		}
	
	}
	
	function drawMapEtc(){
	
	if(map == undefined){
		return;
	}
	
	towersCon.removeChildren();
	
		for(var i = 0;i < towers.length;i++){
	
			towersCon.addChild(g.rectangle(gridSize , gridSize, "red","grey",5,towers[i].x*gridSize,towers[i].y*gridSize));
	
		}
	
		if(base != null){
			towersCon.addChild(g.rectangle(gridSize , gridSize, "green","grey",5,base.x*gridSize,base.y*gridSize));
		}
	
	}
  function reloadMap(){
  
	drawMapLines();
	drawMapEtc();
	
  }
   
  function loadMap(){

	camera.removeChildren();
	
	drawMapBackGround();
	drawMapLines();
	drawMapEtc();
	
    camera.addChild(mapCon)
	camera.addChild(linesCon);
	camera.addChild(towersCon);
	
	
	}  
   
  socket.on('join',function(data){
       //Server will give us an ID until we wait
       id = data.id;
      // console.log("Got join data : " + id);
	  // console.log("Movement Map! :" + JSON.stringify(data.test, null, 4));
	   map = data.map;
       towers = data.towers;
	   mapWidth = data.mapWidth;
	   mapHeight = data.mapHeight;
       console.log("Connected with server!");
       mapLoaded = false;
  });
 
 socket.on('mapUpdate',function(data){
     
     ///console.log("Updating map!");
     map = data.map;
     mapLoaded = false;
     
     towers = data.towers;
     base = data.base;
 });

  
  socket.on('disconnected', function() {

        socket.emit('leave', id);

  });
  
    </script>
</html>